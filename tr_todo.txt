RESEARCH ---------------------------------------------------------------------

- how does harfbuzz select charmap?
- text justification with bidi when reordering of runs changes line width?

MARKUP -----------------------------------------------------------------------

- font: family, size
	- weight: numeric or bold, etc.
	- slant: normal, italic
	- variant: normal, smallcaps
	- stretch: 'ultracondensed', 'extracondensed', 'condensed', 'semicondensed',
		'normal', 'semiexpanded', 'expanded', 'extraexpanded', 'ultraexpanded'
- shaper features: 'dlig=1, -kern, afrc on'
- rise: subscript, superscript, numeric
- color, opacity
- underline_style: none, single, double, low, error; underline_color
- strikethrough: true/false; strikethrough_color
- letter_spacing: numeric
- gravity, gravity_hint?
- abbreviations: b, big, small, i, s, sub, sup, tt, u.

FONT SELECTION ---------------------------------------------------------------

- glyph substitution
	- have a list of fonts and inspect them for unicode coverage
- locale substitution (diff. font per locale, eg. for CJK)

RENDERING --------------------------------------------------------------------

- on translucent text runs, apply opacity on the whole run.
- display missing glyphs as either blank space, invisible or tofu.
	- see faq: http://www.unicode.org/faq/unsup_char.html

SHAPING ----------------------------------------------------------------------

- line breaking

LAYOUTING --------------------------------------------------------------------

- letter spacing
- line height

FINE FEATURE BIN -------------------------------------------------------------

- coloring half-ligatures, see hb_ot_layout_get_ligature_carets
- localized glyphs with font's `locl` table (harfbuzz should select that automatically)
- path-following (eg. on a map; know where to break runs on cursive scripts)
- hyphenation: https://github.com/hunspell/hyphen (what libreoffice uses)

SHAPING ----------------------------------------------------------------------

==============================================================================

instead of reversing RTL runs (which I tried but gave me all sorts of funny
bugs which mixed direction text and line breaks), store the index of all
the shaped glyphs before doing any line breaking (that will be the visual
index), then sort all the glyphs by their cluster values so now they are in
logical order.
Do line breaking pretending the text is unidirectional LTR.
after line breaking, sort the glyphs in each line separately by their visual indices.
This seems to give me proper line breaking, and works whether the base
paragraph direction in LTR or RTL and allows me to keep using whatever line
breaking code I had unmodified.

LAYOUTING --------------------------------------------------------------------



EDITING ----------------------------------------------------------------------

- invisible characters
	- ZW-NBSP: prevents ligatures
	- NBSP: prevents word-wrapping
	- SOFT HYPHEN: hyphenate if word-wrapping
	- ZWJ: force joining
	- ZWNJ: prevent joining
	- WORD JOINER: ZW-NBSP-like
	- LTR/RTL modifiers
	- variation selectors
	- hangul fillers
- look-alike characters:   ; ꓸ ꓹ ꓽ


